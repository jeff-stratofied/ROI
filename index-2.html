<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loan Portfolio — ROI Dashboard</title>

  <!-- =========================
       Styles (Layout + Components)
       ========================= -->
  <style>
    :root{--muted:#64748b;--card:#ffffff;--brand:#0ea5e9;--accent:#7c3aed}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto;color:#0f172a}
    body{background:linear-gradient(180deg,#f1f5f9 0%, #f8fafc 100%)}
    .app{max-width:1200px;margin:20px auto;padding:16px}
    header{display:flex;flex-direction:column;gap:8px;margin-bottom:12px}
    .header-top{display:flex;align-items:center;justify-content:space-between}
    h1{ font-size:20px; margin:0 }
    p.lead{ margin:0; color:var(--muted); font-size:13px }
    .current-date{ font-size:13px; color:var(--muted); margin-top:4px }

    /* KPI tiles */
    .kpis{ display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin:14px 0 18px }
    .kpi{ background:var(--card); padding:12px; border-radius:10px; box-shadow:0 6px 18px rgba(16,24,40,0.04); border:1px solid rgba(15,23,42,0.04); cursor:pointer; transition: transform .18s, box-shadow .18s }
    .kpi:hover{ transform:translateY(-6px); box-shadow:0 12px 30px rgba(15,23,42,0.08) }
    .kpi h3{ margin:0; font-size:12px; color:var(--muted) }
    .kpi p{ margin:8px 0 0; font-size:18px; font-weight:700 }

    .grid{ display:grid; grid-template-columns:repeat(2,1fr); gap:12px; height:calc(100vh - 320px); overflow:auto; padding-right:6px }
    @media(max-width:900px){ .grid{ grid-template-columns:1fr; height:auto } .kpis{ grid-template-columns:repeat(2,1fr) } }

    /* Loan tiles */
    .tile{ display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-radius:12px; background:var(--card); min-height:110px; cursor:pointer; overflow:hidden; transition: transform .18s ease, box-shadow .18s ease }
    .tile:hover{ transform:translateY(-6px); box-shadow:0 12px 30px rgba(15,23,42,0.08) }
    .tile-left{ flex:1; padding-right:10px }
    .loan-name{ font-weight:700; font-size:14px }
    .loan-sub{ font-size:12px; color:var(--muted); margin-top:6px }
    .loan-meta{ display:flex; gap:8px; font-size:12px; color:var(--muted); margin-top:8px }

    .chart-wrap{ width:170px; flex-shrink:0; display:flex; flex-direction:column; align-items:flex-end }
    .mini-label{ font-size:12px; color:var(--muted); margin-bottom:6px }
    svg.sparkline{ width:170px; height:48px; display:block }

    /* Drawer (right-side panel) */
    .drawer{
      position:fixed;
      right:0;
      top:0;
      height:100vh;
      max-width:1000px;
      width:auto;
      min-width:760px;
      background:var(--card);
      box-shadow:-28px 0 80px rgba(2,6,23,0.14);
      transform:translateX(110%);
      transition:transform .28s cubic-bezier(.2,.9,.3,1);
      z-index:90;
      overflow:auto;
      padding:20px;
    }
    .drawer.open{ transform:translateX(0) }
    .drawer-head{ display:flex; align-items:start; justify-content:space-between; gap:8px }
    .close-btn{ background:#f1f5f9; border:none; padding:8px; border-radius:8px; cursor:pointer }

    /* Drawer chart area */
    .drawer-chart {
      width: 100%;
      height: 260px;
      background: linear-gradient(180deg,#ffffff,#fcfeff);
      border-radius: 8px;
      border: 1px solid rgba(15,23,42,0.03);
      display: block;
      position: relative;
      margin-bottom: 8px;
      padding: 0;
    }

    /* Drawer info row: two info cards (primary left, secondary right) */
    .drawer .drawer-info-row { display:flex; gap:12px; margin-bottom:8px; align-items:center; }
    .drawer .info-card { flex:1; background:#f8fafc; padding:12px; border-radius:8px; min-height:48px; display:flex; flex-direction:column; justify-content:center; }
    .drawer .info-card.small { width:160px; align-items:flex-end; }
    .drawer .info-card .muted-small { font-size:12px; color:var(--muted); margin-bottom:6px; display:block; }
    .drawer .info-card .main-val { font-weight:800; font-size:18px; }
    .drawer .info-card .main-val.small { font-size:16px; }

    .amort-wrap{ border:1px solid rgba(15,23,42,0.04); border-radius:8px; padding:8px; max-height:40vh; overflow:auto }
    table{ width:100%; border-collapse:collapse; font-size:13px }
    thead th{ position:sticky; top:0; background:var(--card); padding:8px; text-align:left; color:var(--muted); font-weight:700 }
    td{ padding:8px; border-bottom:1px dashed rgba(15,23,42,0.04); text-align:right }
    td:first-child, th:first-child{ text-align:left }

    .tooltip{ position:fixed; pointer-events:none; background:#0f172a; color:white; padding:6px 8px; border-radius:6px; font-size:12px; transform:translate(-50%,-120%); box-shadow:0 6px 18px rgba(2,6,23,0.2); display:none; z-index:9999; line-height:1.12 }
    .small{ font-size:12px; color:var(--muted) }

    /* ROI table styling */
    .roi-table { width: 100%; border-collapse: collapse; font-size: 13px; background: #fff; }
    .roi-table thead th { text-align: left; padding: 8px; background: #f8fafc; font-weight: 700; color: var(--muted); border-bottom: 1px solid rgba(15,23,42,0.04); }
    .roi-table tbody td { padding: 8px; border-bottom: 1px dashed rgba(15,23,42,0.04); text-align: right; }
    .roi-table tbody td:first-child { text-align:left; }
    .roi-table-container h3 { margin: 0 0 8px; font-size:15px; }
  </style>
</head>
<body>
  <div class="app" role="main">
    <header>
      <div class="header-top">
        <div>
          <h1>Loan Portfolio — ROI Dashboard</h1>
          <p class="lead">Interactive ROI mini-charts • Drawer with expanded ROI and amortization • KPI drawers with primary/secondary cards</p>
        </div>
        <div style="display:flex;gap:10px;align-items:center">
          <div style="font-size:13px;color:var(--muted)">User: <strong style="color:var(--brand)">Jeff L Customer</strong></div>
        </div>
      </div>
      <div class="current-date">Current Month: <strong id="currentMonthLabel">18</strong> (months since first purchase)</div>
    </header>

    <!-- KPI tiles -->
    <section class="kpis" id="kpis"></section>

    <!-- main loan grid -->
    <section class="grid" id="loanGrid" aria-live="polite"></section>
  </div>

  <!-- Drawer (right side) -->
  <aside id="drawer" class="drawer" aria-hidden="true">
    <div class="drawer-head">
      <div>
        <h2 id="drawerTitle">Drawer</h2>
        <div class="muted" id="drawerSub">details</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" id="downloadCsvBtn">Download CSV</button>
        <button class="close-btn" id="closeBtn" aria-label="Close drawer">✕</button>
      </div>
    </div>

    <!-- Drawer info row: primary (left) & secondary (right) -->
    <div class="drawer-info-row">
      <div class="info-card" id="drawerPrimaryCard">
        <div class="muted-small" id="drawerPrimaryTitle">Purchase Price</div>
        <div id="drawerPrimary" class="main-val"></div>
      </div>
      <div class="info-card small" id="drawerSecondaryCard">
        <div class="muted-small" id="drawerSecondaryTitle">Rate</div>
        <div id="drawerSecondary" class="main-val small"></div>
      </div>
    </div>

    <div id="drawerBody">
      <div class="drawer-chart" id="drawerChartArea"></div>

      <div class="legend" id="drawerLegend" style="display:none"></div>

      <div id="drawerExtra"></div>

      <div class="actions" style="padding-top:10px">
        <button class="btn" id="printBtn">Print</button>
        <button class="btn primary" id="copyCsvBtn">Copy CSV</button>
      </div>
    </div>
  </aside>

  <div id="tooltip" class="tooltip" role="status" aria-live="polite"></div>

  <!-- =========================
       Script: data, helpers, UI
       ========================= -->
  <script>
    /************************************************************************
     * Data / Constants
     ************************************************************************/
    const CURRENT_MONTH = 18;
    document.getElementById('currentMonthLabel').textContent = CURRENT_MONTH;

    function monthDiff(d1, d2) {
      const a = new Date(d1);
      const b = new Date(d2);
      return (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
    }

    // sample loans (same as your data)
    const loans = [
      { id:1, purchaseDate:'2024-01-01', purchasePrice:7000, termYears:10, graceYears:0.83, nominalRate:0.0883 },
      { id:2, purchaseDate:'2024-02-01', purchasePrice:7500, termYears:8, graceYears:2, nominalRate:0.075 },
      { id:3, purchaseDate:'2024-03-01', purchasePrice:12000, termYears:12, graceYears:3, nominalRate:0.0825 },
      { id:4, purchaseDate:'2024-04-01', purchasePrice:6000, termYears:9, graceYears:1.5, nominalRate:0.095 },
      { id:5, purchaseDate:'2024-07-01', purchasePrice:5000, termYears:10, graceYears:1, nominalRate:0.09 },
      { id:6, purchaseDate:'2025-01-01', purchasePrice:7500, termYears:5, graceYears:0, nominalRate:0.073 },
      { id:7, purchaseDate:'2025-06-01', purchasePrice:10000, termYears:8, graceYears:0, nominalRate:0.09 },
      { id:8, purchaseDate:'2025-10-01', purchasePrice:5000, termYears:9, graceYears:0.5, nominalRate:0.11 },
      { id:9, purchaseDate:'2025-02-01', purchasePrice:10000, termYears:7, graceYears:0.25, nominalRate:0.10 },
      { id:10,purchaseDate:'2025-03-01', purchasePrice:8000, termYears:3, graceYears:0, nominalRate:0.06 }
    ];

    /************************************************************************
     * Amortization + ROI calculations (same logic as original)
     ************************************************************************/
    function calcAmort(principal, annualRate, termYears, graceYears){
      const monthlyRate = annualRate/12;
      const totalMonths = Math.round(termYears*12);
      const graceMonths = Math.round(graceYears*12);
      const repayMonths = Math.max(1, totalMonths - graceMonths);
      let balance = principal;
      const schedule = [];
      for(let m=1;m<=graceMonths;m++){
        const interest = +(balance*monthlyRate).toFixed(2);
        balance = +(balance + interest).toFixed(2);
        schedule.push({ monthIndex:m, payment:0, principalPaid:0, interest, balance });
      }
      const payment = monthlyRate===0 ? +(balance/repayMonths).toFixed(2) : +((balance*monthlyRate)/(1-Math.pow(1+monthlyRate,-repayMonths))).toFixed(2);
      for(let m=1;m<=repayMonths;m++){
        const interest = +(balance*monthlyRate).toFixed(2);
        const principalPaid = +Math.min(balance, +(payment - interest).toFixed(2));
        balance = +(Math.max(0, balance - principalPaid).toFixed(2));
        schedule.push({ monthIndex: graceMonths + m, payment:+payment.toFixed(2), principalPaid, interest, balance });
      }
      return { payment, schedule };
    }

    const loansWithAmort = loans.map(l=>{
      const amort = calcAmort(l.purchasePrice, l.nominalRate, l.termYears, l.graceYears);
      let cumP=0, cumI=0, cumTotal=0;
      const cumSchedule = amort.schedule.map(r=>{ cumP=+(cumP+r.principalPaid).toFixed(2); cumI=+(cumI+r.interest).toFixed(2); cumTotal=+(cumTotal+r.payment).toFixed(2); return {...r, cumPrincipal:cumP, cumInterest:cumI, cumTotal}; });
      const roiSeries = cumSchedule.map(s => { const loanValue = s.balance + s.cumInterest + s.cumTotal; const roi = (loanValue - l.purchasePrice)/l.purchasePrice; return { month:s.monthIndex, roi, loanValue }; });
      const miniPts = roiSeries.slice(0, Math.min(24, roiSeries.length)).map(s=>({ x:s.month, y:s.roi }));
      return {...l, amort, cumSchedule, roiSeries, miniPts };
    });

    /************************************************************************
     * KPIs computation
     ************************************************************************/
    function computeKPIs(list){
      const total = list.reduce((s,l)=>s + l.purchasePrice, 0);
      const weightedROI = list.reduce((s,l)=> s + l.purchasePrice * ( (l.roiSeries[Math.min(CURRENT_MONTH-1, l.roiSeries.length-1)] || {}).roi || 0 ), 0) / Math.max(1, total);
      const projectedWeightedROI = list.reduce((s,l)=> s + l.purchasePrice * ( (l.roiSeries[l.roiSeries.length-1] || {}).roi || 0 ), 0) / Math.max(1, total);
      const avgRate = list.reduce((s,l)=> s + l.nominalRate * l.purchasePrice, 0) / Math.max(1, total);
      return { total, weightedROI, projectedWeightedROI, avgRate };
    }

    const kpis = computeKPIs(loansWithAmort);

    /************************************************************************
     * UI: build KPI tiles
     ************************************************************************/
    const kpisEl = document.getElementById('kpis');
    kpisEl.innerHTML = ''
      + '<div class="kpi" data-kpi="distribution"><h3>Total Loans</h3><p>' + loansWithAmort.length + '</p></div>'
      + '<div class="kpi" data-kpi="tpv"><h3>Weighted ROI to Date</h3><p id="wroi">' + (kpis.weightedROI*100).toFixed(2) + '%</p></div>'
      + '<div class="kpi" data-kpi="rates"><h3>Projected Weighted ROI</h3><p id="wproj">' + (kpis.projectedWeightedROI*100).toFixed(2) + '%</p></div>'
      + '<div class="kpi" data-kpi="payments"><h3>Avg Rate</h3><p>' + (kpis.avgRate*100).toFixed(2) + '%</p></div>'
    ;

    /************************************************************************
     * Mini sparkline tiles for loans (unchanged behavior, preserved)
     ************************************************************************/
    function buildPathFromPoints(points, w=170, h=48, pad=6){
      if(!points.length) return '';
      const ys = points.map(p=>p.y);
      const minY = Math.min.apply(null, ys); const maxY = Math.max.apply(null, ys); const range = Math.max(1e-6, maxY - minY);
      const stepX = (w - pad*2) / Math.max(1, points.length - 1);
      let d=''; points.forEach(function(p,i){ const x = pad + i*stepX; const y = pad + (h - pad*2) - ((p.y - minY)/range)*(h - pad*2); d += (i===0?('M '+x+' '+y):(' L '+x+' '+y)); }); return d;
    }

    const grid = document.getElementById('loanGrid');
    const tooltip = document.getElementById('tooltip');

    loansWithAmort.forEach(function(loan, idx){
      var tile = document.createElement('div'); tile.className='tile'; tile.setAttribute('tabindex','0');
      var inner = ''
        + '<div class="tile-left">'
        + '<div class="loan-name">Loan ' + loan.id + '</div>'
        + '<div class="loan-sub">$' + loan.purchasePrice.toLocaleString() + '</div>'
        + '<div class="loan-meta"><div>Term: ' + loan.termYears + 'y</div><div>Grace: ' + loan.graceYears + 'y</div></div>'
        + '</div>'
        + '<div class="chart-wrap">'
        + '<div class="mini-label">ROI ' + (( (loan.roiSeries[Math.min(CURRENT_MONTH-1, loan.roiSeries.length-1)]||{}).roi || 0)*100).toFixed(2) + '%</div>'
        + '<svg class="sparkline" viewBox="0 0 170 48" preserveAspectRatio="none" data-idx="' + idx + '" aria-hidden="true"></svg>'
        + '</div>';
      tile.innerHTML = inner;

      tile.addEventListener('click', function(e){ e.stopPropagation(); openDrawerForLoan(loan); });
      tile.addEventListener('keydown', function(e){ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); openDrawerForLoan(loan); } });
      grid.appendChild(tile);

      var svg = tile.querySelector('svg.sparkline'); var w=170,h=48,pad=6;
      var pts = loan.miniPts && loan.miniPts.length?loan.miniPts:loan.roiSeries.map(function(s){return {x:s.month,y:s.roi};});
      var path = buildPathFromPoints(pts, w, h, pad);

      // dashed line location based on purchase date offset
      const earliestDate = "2024-01-01";
      const diff = monthDiff(earliestDate, loan.purchaseDate);
      let currentIdxForLoan = CURRENT_MONTH - diff;
      currentIdxForLoan = Math.max(1, Math.min(loan.roiSeries.length, currentIdxForLoan));
      const stepX = (w - pad*2) / Math.max(1, loan.roiSeries.length - 1);
      const dashX = pad + (currentIdxForLoan - 1) * stepX;

      svg.innerHTML =
          '<path d="' + path + '" fill="none" stroke="#0ea5e9" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />'
        + '<g class="mini-hover"></g>'
        + '<line class="current-line" x1="' + dashX + '" y1="2" x2="' + dashX + '" y2="' + (h-2)
            + '" stroke="#111827" stroke-dasharray="3 3" stroke-opacity="0.6" />';

      svg.addEventListener('mousemove', function(ev){
        const rect = svg.getBoundingClientRect();
        const relX = ev.clientX - rect.left;
        const stepX = (w - pad*2) / Math.max(1, pts.length - 1);
        let idxNearest = Math.round((relX - pad) / stepX);
        idxNearest = Math.max(0, Math.min(pts.length - 1, idxNearest));
        const pt = pts[idxNearest];
        const p = loan.roiSeries[pt.x - 1] || loan.roiSeries[idxNearest];
        tooltip.style.left = ev.clientX + "px";
        tooltip.style.top = (ev.clientY - 10) + "px";
        tooltip.style.display = "block";
        tooltip.innerHTML = "M" + p.month + " • ROI " + (p.roi * 100).toFixed(2) + "%";

        // draw hover dot
        const hoverG = svg.querySelector("g.mini-hover");
        hoverG.innerHTML = "";
        const ys = pts.map(pt => pt.y);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const rangeY = Math.max(1e-6, maxY - minY);
        const cx = pad + idxNearest * stepX;
        const cy = pad + (h - pad*2) - ((pt.y - minY) / rangeY) * (h - pad*2);
        const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        c.setAttribute("cx", cx);
        c.setAttribute("cy", cy);
        c.setAttribute("r", 3.6);
        c.setAttribute("fill", "#0ea5e9");
        c.setAttribute("stroke", "#fff");
        c.setAttribute("stroke-width", "1");
        hoverG.appendChild(c);
      });
      svg.addEventListener('mouseleave', function(){ tooltip.style.display='none'; var hoverG=svg.querySelector('g.mini-hover'); if(hoverG) hoverG.innerHTML=''; });
    });

    /************************************************************************
     * Drawer utilities: small helpers to build SVG charts with hover
     ************************************************************************/

    // Generic line chart builder (series: array of {x,y})
    function createLineChart(containerEl, series, opts = {}) {
      containerEl.innerHTML = '';
      const svgNS = "http://www.w3.org/2000/svg";
      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(320, rect.width || 600);
      const h = opts.h || 260;
      const pad = opts.pad || 28;

      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.style.display = "block";

      // ensure at least 2 points
      const data = series.length ? series.slice() : [{x:0,y:0}];
      const ys = data.map(d => d.y);
      const xs = data.map(d => d.x);
      const minY = Math.min(...ys); const maxY = Math.max(...ys);
      const minX = Math.min(...xs); const maxX = Math.max(...xs);
      const rangeY = Math.max(1e-6, maxY - minY);
      const rangeX = Math.max(1e-6, maxX - minX);

      const stepX = (w - pad*2) / Math.max(1, data.length - 1);
      function toXY(d,i){ const x = pad + i * stepX; const y = pad + (h - pad*2) - ((d.y - minY)/rangeY) * (h - pad*2); return [x,y]; }

      // grid lines
      for(let gy=0; gy<5; gy++){
        const y = pad + gy * ((h - pad*2)/4);
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', pad); line.setAttribute('x2', w - pad);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#eef2f7'); line.setAttribute('stroke-width', '1');
        svg.appendChild(line);
      }

      // path
      let path = '';
      data.forEach(function(p,i){ const xy = toXY(p,i); path += (i===0?('M '+xy[0]+' '+xy[1]):(' L '+xy[0]+' '+xy[1])); });
      const el = document.createElementNS(svgNS, 'path');
      el.setAttribute('d', path); el.setAttribute('fill','none'); el.setAttribute('stroke', opts.color || '#0ea5e9'); el.setAttribute('stroke-width','2');
      svg.appendChild(el);

      // interactive hover group
      const vLine = document.createElementNS(svgNS, 'line'); vLine.setAttribute('stroke', '#111827'); vLine.setAttribute('stroke-dasharray','3 4'); vLine.setAttribute('stroke-opacity','0.6');
      svg.appendChild(vLine);
      const hoverGroup = document.createElementNS(svgNS, 'g'); hoverGroup.setAttribute('class','hover'); svg.appendChild(hoverGroup);

      // mouse interactions
      svg.addEventListener('mousemove', function(ev){
        const rect = svg.getBoundingClientRect();
        const svgX = ev.clientX - rect.left;
        // use nearest index via stepX
        let idx = Math.round((svgX - pad) / stepX);
        idx = Math.max(0, Math.min(data.length - 1, idx));
        const point = data[idx];
        const [cx, cy] = toXY(point, idx);
        // vertical line
        vLine.setAttribute('x1', cx); vLine.setAttribute('x2', cx); vLine.setAttribute('y1', pad); vLine.setAttribute('y2', h - pad);
        // hover circle
        hoverGroup.innerHTML = '';
        const c = document.createElementNS(svgNS, 'circle');
        c.setAttribute('cx', cx); c.setAttribute('cy', cy); c.setAttribute('r', 4); c.setAttribute('fill', opts.color || '#0ea5e9'); c.setAttribute('stroke','#fff'); c.setAttribute('stroke-width','1');
        hoverGroup.appendChild(c);

        // tooltip
        tooltip.style.display = 'block';
        tooltip.style.left = (rect.left + cx) + 'px';
        tooltip.style.top = (rect.top + cy - 28) + 'px';
        const label = (opts.labelFn && typeof opts.labelFn === 'function') ? opts.labelFn(point, idx) : (`M${point.x} • ${ (point.y*100).toFixed(2) }%`);
        tooltip.innerHTML = label;
      });

      svg.addEventListener('mouseleave', function(){ hoverGroup.innerHTML = ''; tooltip.style.display = 'none'; });

      containerEl.appendChild(svg);
      return svg;
    }

    // Generic bar chart builder for categorical timeseries (keys array / values array)
    function createBarChart(containerEl, keys, values, opts = {}) {
      containerEl.innerHTML = '';
      const svgNS = "http://www.w3.org/2000/svg";
      const rect = containerEl.getBoundingClientRect();
      const w = Math.max(320, rect.width || 600);
      const h = opts.h || 260;
      const padL = opts.padL || 55;
      const padR = opts.padR || 20;
      const padT = opts.padT || 25;
      const padB = opts.padB || 55;

      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
      svg.setAttribute("width", "100%");
      svg.setAttribute("height", "100%");
      svg.style.display = "block";

      const maxValue = Math.max(...values, 1);
      const barW = (w - padL - padR) / Math.max(1, keys.length);

      // horizontal grid lines & y labels
      for (let i = 0; i <= 5; i++) {
        const y = padT + (h - padT - padB) * (i / 5);
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", padL); line.setAttribute("x2", w - padR); line.setAttribute("y1", y); line.setAttribute("y2", y); line.setAttribute("stroke", "#eef2f7");
        svg.appendChild(line);
        const value = maxValue * (1 - i / 5);
        const lbl = document.createElementNS(svgNS, "text");
        lbl.textContent = "$" + Math.round(value).toLocaleString();
        lbl.setAttribute("x", padL - 10); lbl.setAttribute("y", y + 4); lbl.setAttribute("font-size", "11"); lbl.setAttribute("fill", "#64748b"); lbl.setAttribute("text-anchor", "end");
        svg.appendChild(lbl);
      }

      const hoverG = document.createElementNS(svgNS, "g"); hoverG.setAttribute("class", "hover"); svg.appendChild(hoverG);

      // bars
      keys.forEach((key, i) => {
        const amount = values[i];
        const x = padL + i * barW;
        const barHeight = (amount / maxValue) * (h - padT - padB);
        const y = padT + (h - padT - padB) - barHeight;
        const bar = document.createElementNS(svgNS, "rect");
        bar.setAttribute("x", x + 6); bar.setAttribute("y", y); bar.setAttribute("width", barW - 12); bar.setAttribute("height", barHeight);
        bar.setAttribute("rx", 4); bar.setAttribute("fill", opts.color || "#0ea5e9"); bar.style.cursor = "pointer";
        bar.addEventListener('mousemove', ev => {
          hoverG.innerHTML = "";
          const rect = svg.getBoundingClientRect();
          const cx = ev.clientX - rect.left;
          const cy = ev.clientY - rect.top - 14;
          const bg = document.createElementNS(svgNS, "rect");
          bg.setAttribute("x", cx - 40); bg.setAttribute("y", cy - 18); bg.setAttribute("width", 80); bg.setAttribute("height", 20); bg.setAttribute("rx", 4); bg.setAttribute("fill", "#ffffff"); bg.setAttribute("stroke", "#cbd5e1");
          const tip = document.createElementNS(svgNS, "text");
          tip.textContent = "$" + amount.toLocaleString(); tip.setAttribute("x", cx); tip.setAttribute("y", cy - 4); tip.setAttribute("font-size", "12"); tip.setAttribute("text-anchor", "middle"); tip.setAttribute("fill", "#0f172a"); tip.setAttribute("font-weight", "600");
          hoverG.appendChild(bg); hoverG.appendChild(tip);
        });
        bar.addEventListener('mouseleave', () => { hoverG.innerHTML = ""; });
        svg.appendChild(bar);

        // x labels
        const t = document.createElementNS(svgNS, "text");
        t.textContent = key;
        t.setAttribute("x", x + barW / 2); t.setAttribute("y", h - padB + 22); t.setAttribute("font-size", "11"); t.setAttribute("fill", "#64748b"); t.setAttribute("text-anchor", "middle");
        svg.appendChild(t);
      });

      containerEl.appendChild(svg);
      return svg;
    }

    // Histogram builder (values array)
    function createHistogram(containerEl, values, bins = 6, opts = {}) {
      containerEl.innerHTML = '';
      // compute bins
      const minV = Math.min(...values); const maxV = Math.max(...values);
      const range = Math.max(1e-6, maxV - minV);
      const binSize = range / bins;
      const counts = new Array(bins).fill(0);
      values.forEach(v => {
        let idx = Math.floor((v - minV) / binSize);
        if (idx === bins) idx = bins - 1;
        counts[idx] += 1;
      });
      const labels = counts.map((_, i) => {
        const a = minV + i*binSize; const b = a + binSize;
        return `${(a*100).toFixed(1)}–${(b*100).toFixed(1)}%`;
      });
      return createBarChart(containerEl, labels, counts, opts);
    }

    /************************************************************************
     * Drawer control variables & helpers
     ************************************************************************/
    const drawer = document.getElementById('drawer');
    const drawerTitle = document.getElementById('drawerTitle');
    const drawerSub = document.getElementById('drawerSub');
    const drawerPrimaryTitle = document.getElementById('drawerPrimaryTitle');
    const drawerPrimary = document.getElementById('drawerPrimary');
    const drawerSecondaryTitle = document.getElementById('drawerSecondaryTitle');
    const drawerSecondary = document.getElementById('drawerSecondary');
    const drawerChartArea = document.getElementById('drawerChartArea');
    const drawerLegend = document.getElementById('drawerLegend');
    const drawerExtra = document.getElementById('drawerExtra');

    document.getElementById('closeBtn').addEventListener('click', closeDrawer);
    document.addEventListener('keydown', function(e){ if(e.key==='Escape') closeDrawer(); });

    function closeDrawer(){
      drawer.classList.remove('open');
      drawer.setAttribute('aria-hidden','true');
      tooltip.style.display='none';
    }

    /************************************************************************
     * Individual loan drawer (unchanged except using primary/secondary fields)
     ************************************************************************/
    var currentLoan = null, currentMode = null;
    function openDrawerForLoan(loan){
      currentMode='loan'; currentLoan=loan;
      drawerTitle.textContent = 'Loan ' + loan.id;
      drawerSub.textContent = 'Purchased: ' + loan.purchaseDate;
      drawerPrimaryTitle.textContent = 'Purchase Price';
      drawerPrimary.textContent = '$' + loan.purchasePrice.toLocaleString();
      drawerSecondaryTitle.textContent = 'Nominal Rate';
      drawerSecondary.textContent = (loan.nominalRate*100).toFixed(2) + '%';

      // Drawer chart (loan ROI series) using createLineChart
      const schedule = loan.roiSeries.map(s => ({ x: s.month, y: s.roi }));
      createLineChart(drawerChartArea, schedule, {
        color: '#0ea5e9',
        labelFn: (pt) => `M${pt.x} • ROI ${(pt.y*100).toFixed(2)}%`
      });

      // ROI table population (same as before) — keep in drawerExtra
      drawerExtra.innerHTML = ''; // clear previous
      const feePerMonth = 3.00;
      const cum = loan.cumSchedule || [];
      const sched = loan.amort && loan.amort.schedule ? loan.amort.schedule : [];
      // build simple table for top N months (or whole)
      let tableHtml = `<div style="margin-top:12px"><strong class="small">Loan amort / ROI (first 10 months)</strong><div style="margin-top:8px"><table class="roi-table"><thead><tr><th>Month</th><th>Payment</th><th>Principal</th><th>Interest</th><th>Accrued Int</th><th>Fees</th><th>Loan Value</th><th>ROI</th></tr></thead><tbody>`;
      sched.slice(0, 24).forEach((r) => {
        const month = r.monthIndex;
        const cs = cum.find(c => c.monthIndex === month) || { cumPrincipal:0, cumInterest:0, cumTotal:0 };
        const payment = Number(r.payment) || 0;
        const accruedInterest = Number(cs.cumInterest) || 0;
        const cumulativePayments = Number(cs.cumTotal) || 0;
        const fees = +(month * feePerMonth).toFixed(2);
        const loanValue = +(Number(r.balance || 0) + accruedInterest + cumulativePayments - fees).toFixed(2);
        const roiPct = +(((loanValue - loan.purchasePrice) / loan.purchasePrice) * 100).toFixed(2);
        tableHtml += `<tr><td>M${month}</td><td>$${payment.toFixed(2)}</td><td>$${(r.principalPaid||0).toFixed(2)}</td><td>$${(r.interest||0).toFixed(2)}</td><td>$${accruedInterest.toFixed(2)}</td><td>$${fees.toFixed(2)}</td><td>$${loanValue.toLocaleString(undefined,{minimumFractionDigits:2})}</td><td>${roiPct.toFixed(2)}%</td></tr>`;
      });
      tableHtml += `</tbody></table></div></div>`;
      drawerExtra.innerHTML = tableHtml;

      drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false'); drawer.scrollTop = 0;
    }

    /************************************************************************
     * KPI Drawer renderers:
     * - renderDistributionDrawer (Total Loans)
     * - renderTPVDrawer (Weighted ROI to Date)
     * - renderRatesDrawer (Projected Weighted ROI)
     * - renderPaymentsDrawer (Avg Rate)
     ************************************************************************/

    // Helper: compute monthly totals object: { '2024-01': total, ...}
    function getMonthlyTotals(loansList) {
      const totals = {};
      loansList.forEach(l => {
        const d = new Date(l.purchaseDate);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2,'0')}`;
        totals[key] = (totals[key] || 0) + l.purchasePrice;
      });
      return totals;
    }

    // TOTAL LOANS drawer (bar chart) — Primary left: Total Invested; Secondary right: Total Loans
    function renderDistributionDrawer(){
      currentMode='kpi'; currentLoan=null;
      drawerTitle.textContent = 'Total Loans';
      drawerSub.textContent = 'Loan Purchase Amounts Per Month';

      // Primary / secondary
      const totalsObj = getMonthlyTotals(loansWithAmort);
      const keys = Object.keys(totalsObj).sort();
      const values = keys.map(k => totalsObj[k]);
      const totalInvested = values.reduce((a,b)=>a+b,0);
      drawerPrimaryTitle.textContent = 'Total Invested';
      drawerPrimary.textContent = '$' + totalInvested.toLocaleString();
      drawerSecondaryTitle.textContent = 'Total Loans';
      drawerSecondary.textContent = loansWithAmort.length + ' loans';

      // Chart: bar chart by month
      createBarChart(drawerChartArea, keys, values, { color: '#0ea5e9' });

      // Extra: loans list and actions
      drawerExtra.innerHTML = `
        <h3 style="margin-top:12px;margin-bottom:8px">Loans</h3>
        <div style="border:1px solid rgba(15,23,42,0.06);border-radius:8px;max-height:260px;overflow:auto;background:#fff;padding:6px;">
          <table style="width:100%;border-collapse:collapse;font-size:13px">
            <thead>
              <tr><th style="text-align:left">Loan</th><th style="text-align:left">Purchase</th><th>Amount</th><th>Rate</th></tr>
            </thead>
            <tbody>
              ${loansWithAmort.map(l => `
                <tr>
                  <td style="text-align:left">Loan ${l.id}</td>
                  <td>${l.purchaseDate}</td>
                  <td>$${l.purchasePrice.toLocaleString()}</td>
                  <td>${(l.nominalRate*100).toFixed(2)}%</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
        <div style="margin-top:12px;display:flex;gap:10px;">
          <button class="btn" onclick="window.print()">Print</button>
          <button class="btn" onclick="copyPortfolioCSV()">Copy CSV</button>
        </div>
      `;

      drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false');
    }

    // Weighted ROI to Date drawer — Primary left: Weighted ROI to Date; Secondary right: Current Portfolio Value
    function renderTPVDrawer(){
      currentMode='kpi'; currentLoan=null;
      drawerTitle.textContent = 'Portfolio — Weighted ROI (To Date)';
      drawerSub.textContent = 'Snapshot';

      // compute current portfolio value across loans (month = CURRENT_MONTH)
      let portfolioValue = 0;
      loansWithAmort.forEach(l => {
        const idx = Math.min(CURRENT_MONTH-1, l.roiSeries.length - 1);
        const row = l.roiSeries[idx] || { loanValue: l.purchasePrice };
        portfolioValue += (row.loanValue || l.purchasePrice);
      });

      drawerPrimaryTitle.textContent = 'Weighted ROI to Date';
      drawerPrimary.textContent = (kpis.weightedROI * 100).toFixed(2) + '%';
      drawerSecondaryTitle.textContent = 'Portfolio Value';
      drawerSecondary.textContent = '$' + portfolioValue.toLocaleString();

      // Chart: weighted portfolio ROI over time (0..CURRENT_MONTH)
      // build weighted ROI series by month
      const monthsMax = loansWithAmort.reduce((m,l) => Math.max(m, l.roiSeries.length), 0);
      const upTo = Math.min(monthsMax, Math.max(CURRENT_MONTH, 1));
      const series = [];
      for(let m=1;m<=upTo;m++){
        // weighted roi for month m across loans (where available)
        let totalInvested = 0, weightedSum = 0;
        loansWithAmort.forEach(l => {
          const entry = l.roiSeries.find(r => r.month === m);
          const invested = l.purchasePrice;
          if(entry){
            weightedSum += invested * entry.roi;
            totalInvested += invested;
          } else {
            // if loan not yet started at month m, exclude
          }
        });
        const wroi = totalInvested ? (weightedSum / totalInvested) : 0;
        series.push({ x: m, y: wroi });
      }

      createLineChart(drawerChartArea, series, {
        color: '#0f172a',
        labelFn: (pt) => `M${pt.x} • Weighted ROI ${(pt.y*100).toFixed(2)}%`
      });

      drawerExtra.innerHTML = `<div style="margin-top:10px"><strong class="small">Weighted ROI to date</strong><div style="font-size:18px;font-weight:800;margin-top:6px">${(kpis.weightedROI*100).toFixed(2)}%</div></div>`;
      drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false');
    }

    // Projected Weighted ROI drawer — Primary: Projected Weighted ROI; Secondary: Projected Portfolio Value (at loan maturities)
    function renderRatesDrawer(){
      currentMode='kpi'; currentLoan=null;
      drawerTitle.textContent = 'Projected Weighted ROI';
      drawerSub.textContent = 'Projection to maturity';

      // projected portfolio value: sum of loan.roiSeries last loanValue
      const projectedPortfolioValue = loansWithAmort.reduce((s,l) => {
        const last = l.roiSeries[l.roiSeries.length - 1] || { loanValue: l.purchasePrice };
        return s + (last.loanValue || l.purchasePrice);
      }, 0);

      drawerPrimaryTitle.textContent = 'Projected Weighted ROI';
      drawerPrimary.textContent = (kpis.projectedWeightedROI * 100).toFixed(2) + '%';
      drawerSecondaryTitle.textContent = 'Projected Portfolio Value';
      drawerSecondary.textContent = '$' + projectedPortfolioValue.toLocaleString();

      // Build a projected weighted ROI curve:
      // pick a months range up to the max loan length and compute weighted ROI each month (where loans have data)
      const monthsMax = loansWithAmort.reduce((m,l) => Math.max(m, l.roiSeries.length), 0);
      const series = [];
      for(let m=1;m<=monthsMax;m++){
        let totalInvested=0, weightedSum=0;
        loansWithAmort.forEach(l => {
          const entry = l.roiSeries.find(r => r.month === m);
          if(entry){
            weightedSum += l.purchasePrice * entry.roi;
            totalInvested += l.purchasePrice;
          }
        });
        const val = totalInvested ? weightedSum / totalInvested : 0;
        series.push({ x: m, y: val });
      }

      createLineChart(drawerChartArea, series, {
        color: '#7c3aed',
        labelFn: (pt) => `M${pt.x} • Projected ROI ${(pt.y*100).toFixed(2)}%`
      });

      drawerExtra.innerHTML = `<div style="margin-top:10px"><strong class="small">Projected Weighted ROI (to maturity)</strong></div>`;
      drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false');
    }

    // Avg Rate drawer — Primary: Average Rate; Secondary: Weighted Avg Rate (or range). Chart: histogram of nominal rates
    function renderPaymentsDrawer(){
      currentMode='kpi'; currentLoan=null;
      drawerTitle.textContent = 'Average / Rate Distribution';
      drawerSub.textContent = 'Portfolio nominal rates';

      drawerPrimaryTitle.textContent = 'Average Rate';
      drawerPrimary.textContent = (kpis.avgRate * 100).toFixed(2) + '%';

      // compute weighted average rate (by purchase price)
      const total = loansWithAmort.reduce((s,l)=>s + l.purchasePrice,0);
      const weightedAvgRate = loansWithAmort.reduce((s,l)=> s + l.nominalRate * l.purchasePrice, 0) / Math.max(1, total);
      drawerSecondaryTitle.textContent = 'Weighted Avg Rate';
      drawerSecondary.textContent = (weightedAvgRate * 100).toFixed(2) + '%';

      // histogram of nominal rates
      const rates = loansWithAmort.map(l => l.nominalRate);
      createHistogram(drawerChartArea, rates, 6, { color: '#0ea5e9' });

      drawerExtra.innerHTML = `<div style="margin-top:10px" class="small">Rates range: ${(Math.min(...rates)*100).toFixed(2)}% — ${(Math.max(...rates)*100).toFixed(2)}%</div>`;
      drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false');
    }

    /************************************************************************
     * Wiring KPI tile clicks to drawer renderers
     ************************************************************************/
    document.querySelectorAll('.kpi').forEach(function(k){
      k.addEventListener('click', function(ev){
        ev.stopPropagation();
        const key = k.getAttribute('data-kpi');
        // route by key
        if(key === 'distribution') renderDistributionDrawer();
        if(key === 'tpv') renderTPVDrawer();
        if(key === 'rates') renderRatesDrawer();
        if(key === 'payments') renderPaymentsDrawer();
      });
    });

    /************************************************************************
     * CSV / Misc helpers
     ************************************************************************/
    function copyPortfolioCSV() {
      let rows = [["Loan","Purchase Date","Amount","Rate"]];
      loansWithAmort.forEach(l=>{
        rows.push(["Loan " + l.id, l.purchaseDate, l.purchasePrice, (l.nominalRate*100).toFixed(2)+"%"]);
      });
      const csv = rows.map(r=>r.join(",")).join("\n");
      navigator.clipboard.writeText(csv);
      alert("CSV copied to clipboard");
    }

    function amortToCSV(loan){
      var rows=[['Month','Payment','Principal','Interest','Balance']];
      loan.amort.schedule.forEach(function(r){ rows.push([r.monthIndex, r.payment.toFixed(2), r.principalPaid.toFixed(2), r.interest.toFixed(2), r.balance.toFixed(2)]); });
      return rows.map(function(r){ return r.join(','); }).join('\n');
    }

    document.getElementById('copyCsvBtn')?.addEventListener('click', async function(){
      if(currentMode!=='loan' || !currentLoan) return alert('Open an individual loan drawer to copy CSV');
      var csv = amortToCSV(currentLoan);
      try{ await navigator.clipboard.writeText(csv); alert('CSV copied to clipboard'); }
      catch(e){ alert('Copy failed — browser denied clipboard access'); }
    });

    document.getElementById('downloadCsvBtn')?.addEventListener('click', function(){
      if(currentMode==='loan' && currentLoan){
        var csv = amortToCSV(currentLoan);
        var blob = new Blob([csv],{type:'text/csv;charset=utf-8;'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = 'loan-' + currentLoan.id + '-amort.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      } else alert('Download CSV is supported for individual loan drawers only.');
    });

    document.getElementById('printBtn')?.addEventListener('click', function(){ window.print(); });

    // close drawer when clicking outside (keeps existing semantics)
    document.addEventListener('click', function (e) {
      if(!drawer.classList.contains('open')) return;
      var clickedInsideDrawer = drawer.contains(e.target);
      var clickedTile = !!e.target.closest('.tile');
      if(!clickedInsideDrawer && !clickedTile) closeDrawer();
    });

    // hide tooltip when scrolling grid
    document.querySelector('.grid').addEventListener('scroll', function(){ tooltip.style.display='none'; });

    // end of script
  </script>
</body>
</html>
